# this script is developed for material compensation, and it is only suitable for the G-Code files generated by ModelLightV3


# G0和G1均用于直线挤出，
# 区别：G0用于非挤压挤出，G1用于挤出挤压

# noinspection PyUnresolvedReferences
import math
file_in = open('input.gcode', "r")
file_out = open('output.gcode','w')

# layer_count变量为层数，设定初始层数为0
layer_count = 0
# 初始基台半径
INITIAL_RADIUS = 30
# 分层高度
layer_height = 0.15
# 进行初始赋值
previous_x_value = 0
previous_y_value = 0
x_value_actual  = 0
previous_x_value_actual  = 0

# previous_e_value 是上一个的E的数值
previous_e_value = 0
# previous_e_value_modified 为先前的挤出量，是上一个挤出补偿后的E的值
previous_e_value_modified = 0




# 变量G91_count,用来标志G91是否出现。
G91_count =0

for line in file_in:
    line = line.strip()  # 去除换行符并打印每一行
     #print(line)
    # 接下来进行文件的处理，进行判断层数  layer_count 为当前层数
    if line.startswith(";layer:"):  # 判断是否为包含层数信息的行
          layer_count += 1
        #print(layer_count)

    # 计算当前直径
    current_radius = INITIAL_RADIUS + layer_count * layer_height

    if 'G91' in line:  # 因为最后有个G91重置坐标系数值，因此后边的内容不进行修改。
        G91_count = 1
    # 层数必须从第一层开始，防止开头修改的代码导致的错误

    # # 将注释行直接输出
    # if ';' in line:
    #     file_out.write(line + '\n')

    if layer_count >= 1 and G91_count == 0 and ';' not in line and 'M' not in line:
        # 进行挤出补偿
        # 判断G0还是G1在line中，如果G0在，则是空运行，
        # 如果G0在line中，且Z在line中，则直接输出，因为不涉及X、Y坐标,若Z不在，则存在XY坐标
        if 'G0' in line:
            if 'Z' in line:
                file_out.write(line+'\n')
            else: # 进行提取XY坐标，进行更新坐标数据
                x_index = line.index('X')
                y_index = line.index('Y')
                x_value = float(line[x_index + 1:y_index])     # 进行提取X坐标
                x_value_actual = x_value * current_radius/INITIAL_RADIUS # 实际的X坐标
                y_value = float(line[y_index + 1:].strip())  # 提取Y坐标

                # 进行更新一下 X Y的实际坐标
                previous_x_value = x_value
                previous_y_value = y_value
                previous_x_value_actual = x_value_actual


                # 对于G0行，不需要修改，可以直接将line输出到文件中
                file_out.write(line+'\n')

        # 判断G1，提取坐标，进行补偿
        if 'G1' in line:
            if 'X' not in line: # 这部分是回抽，不需要挤出补偿，比如G1 F6000 E27.06261
                e_index = line.index("E")  # 获取"E"在当前行的索引
                e_value = line[e_index + 1:].strip()  # 提取"E"后面的数值部分并去除空格和换行符,并进行类型转换
                e_value = float(e_value)
                e_value_modified = round(previous_e_value_modified + e_value - previous_e_value,5)
                # 重构line，写入文件
                modified_line = line[:e_index + 1] + str(e_value_modified) + "\n"  # 构建修改后的行
                file_out.write(modified_line)  # 将修改后的行添加到输出文件中

            else: # 此部分需要补偿
                x_index = line.index('X')
                y_index = line.index('Y')
                e_index = line.index("E")  # 获取"E"在当前行的索引
                x_value = float(line[x_index + 1:y_index-1])  # 进行提取X坐标
                x_value_actual = x_value * current_radius/INITIAL_RADIUS  # 计算圆弧段X坐标的长度
                y_value = float(line[y_index + 1:e_index-1])  # 提取Y坐标
                e_value = float(line[e_index + 1:].strip())  # 提取"E"后面的数值部分并去除空格和换行符,并进行类型转换

                # arc_length为基于基台的弧长，actual_arc_length 为实际的弧长
                arc_length = math.sqrt((x_value - previous_x_value) ** 2 + (y_value - previous_y_value) ** 2)

                actual_arc_length = math.sqrt(
                    (x_value_actual - previous_x_value_actual) ** 2 + (y_value - previous_y_value) ** 2)  # 因为Y坐标不存在长度问题

                # K为比例系数
                k = actual_arc_length / arc_length
                # 挤出量更改
                e_value_modified =round(previous_e_value_modified + k * (e_value - previous_e_value),5)  # k * e_value 按照比例关系进行补偿

                # 补偿后写入输出文件中
                modified_line = line[:e_index + 1] + str(e_value_modified) + "\n"  # 构建修改后的行
                file_out.write(modified_line)  # 将修改后的行添加到输出文件中

                # 进行更新一下 X Y的实际坐标
                previous_x_value = x_value
                previous_y_value = y_value
                previous_x_value_actual = x_value_actual
                previous_e_value = e_value
                previous_e_value_modified = e_value_modified
    else:
        file_out.write(line + '\n')


    # # 此部分对变量进行更新
    #
    # previous_e_value = e_value
    # previous_e_value_modified = e_value_modified

file_in.close()
file_out.close()
print('补偿完成')
